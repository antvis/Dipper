{"version":3,"sources":["webpack://InversifyReact/webpack/universalModuleDefinition","webpack://InversifyReact/./src/hooks.ts","webpack://InversifyReact/./src/internal.ts","webpack://InversifyReact/./src/provider.tsx","webpack://InversifyReact/./src/resolve.ts","webpack://InversifyReact/external {\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\",\"root\":\"React\"}","webpack://InversifyReact/webpack/bootstrap","webpack://InversifyReact/./src/index.ts"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__888__","useContainer","resolve","resolveValue","ref","container","useContext","InversifyReactContext","Error","useRef","current","v","serviceId","get","resolveDefault","isBound","getAll","createContext","undefined","displayName","AdministrationKey","getClassAdministration","target","administration","accepts","Object","defineProperty","enumerable","writable","value","getInstanceAdministration","context","properties","ensureAcceptContext","contextType","name","set","createProperty","type","options","getter","isOptional","defaultValue","descriptor","getOwnPropertyDescriptor","Provider","children","containerProp","standalone","standaloneProp","useState","parentContainer","parent","applyResolveDecorator","constructor","getDesignType","Reflect","getMetadata","optional","args","length","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","useAllInjections","useInjection","useOptionalInjection"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InversifyReact\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"InversifyReact\"] = factory(root[\"React\"]);\n})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__888__) {\nreturn ","import { interfaces } from 'inversify';\r\nimport { useContext, useRef } from 'react';\r\n\r\nimport { InversifyReactContext } from './internal';\r\n\r\n/**\r\n * internal utility hook\r\n * @see https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily\r\n *\r\n * Q: why not `useMemo`?\r\n * A: it does not guarantee same instance\r\n * @see https://reactjs.org/docs/hooks-reference.html#usememo\r\n *\r\n * Q: why not `useState`?\r\n * A: it's possible to use state factory `useState(() => container.get(...))`,\r\n * but ref is probably slightly more optimal because it's not related to re-rendering\r\n * (which we don't need anyway)\r\n */\r\nfunction useLazyRef<T>(resolveValue: () => T): T {\r\n    const ref = useRef<{ v: T }>();\r\n    if (!ref.current) {\r\n        ref.current = { v: resolveValue() };\r\n    }\r\n    return ref.current.v;\r\n}\r\n\r\n/**\r\n * Resolves container or something from container (if you specify resolving function)\r\n */\r\nexport function useContainer(): interfaces.Container\r\nexport function useContainer<T>(resolve: (container: interfaces.Container) => T): T\r\nexport function useContainer<T>(resolve?: (container: interfaces.Container) => T): interfaces.Container | T {\r\n    const container = useContext(InversifyReactContext);\r\n    if (!container) {\r\n        throw new Error(\r\n            'Cannot find Inversify container on React Context. ' +\r\n            '`Provider` component is missing in component tree.'\r\n        );\r\n    }\r\n    return resolve\r\n        ? useLazyRef(() => resolve(container))\r\n        : container;\r\n}\r\n\r\n/**\r\n * Resolves injection by id (once, at first render).\r\n */\r\nexport function useInjection<T>(serviceId: interfaces.ServiceIdentifier<T>): T {\r\n    return useContainer(\r\n        container => container.get<T>(serviceId)\r\n    );\r\n}\r\n\r\n// overload with default value resolver;\r\n// no restrictions on default `D` (e.g. `D extends T`) - freedom and responsibility of \"user-land code\"\r\nexport function useOptionalInjection<T, D>(\r\n    serviceId: interfaces.ServiceIdentifier<T>,\r\n    // motivation:\r\n    // to guarantee that \"choosing the value\" process happens exactly once and\r\n    // to save users from potential bugs with naive `useOptionalInjection(...) ?? myDefault`;\r\n    // this callback will be executed only if binding is not found on container\r\n    resolveDefault: (container: interfaces.Container) => D\r\n): T | D;\r\n// overload without default value resolver\r\nexport function useOptionalInjection<T>(\r\n    serviceId: interfaces.ServiceIdentifier<T>\r\n): T | undefined;\r\n/**\r\n * Resolves injection if it's bound in container\r\n */\r\nexport function useOptionalInjection<T, D>(\r\n    serviceId: interfaces.ServiceIdentifier<T>,\r\n    resolveDefault: (container: interfaces.Container) => D | undefined = () => undefined\r\n): T | D | undefined {\r\n    return useContainer(\r\n        container => container.isBound(serviceId)\r\n            ? container.get(serviceId)\r\n            : resolveDefault(container)\r\n    );\r\n}\r\n\r\n/**\r\n * uses container.getAll(), works like @multiInject()\r\n * https://github.com/inversify/InversifyJS/blob/master/wiki/container_api.md#containergetall\r\n * https://github.com/inversify/InversifyJS/blob/master/wiki/multi_injection.md\r\n */\r\nexport function useAllInjections<T>(serviceId: interfaces.ServiceIdentifier<T>): readonly T[] {\r\n    return useContainer(\r\n        container => container.getAll(serviceId)\r\n    );\r\n}\r\n","import { ComponentClass, Component, createContext } from 'react';\r\nimport { interfaces } from 'inversify';\r\n\r\ntype InversifyReactContextValue = interfaces.Container | undefined;\r\nconst InversifyReactContext = createContext<InversifyReactContextValue>(undefined);\r\nInversifyReactContext.displayName = 'InversifyReactContext';\r\n\r\n// @see https://reactjs.org/docs/context.html#classcontexttype\r\nconst contextTypeKey = 'contextType';\r\n\r\n// Object.defineProperty is used to associate data with objects (component classes and instances)\r\n// #DX: ES6 WeakMap could be used instead in the future when polyfill won't be required anymore\r\nconst AdministrationKey = '~$inversify-react';\r\n\r\n// internal data associated with component class\r\ntype DiClassAdministration = {\r\n\taccepts: boolean;\r\n}\r\n\r\n// internal data associated with component instance\r\ntype DiInstanceAdministration = {\r\n\tcontainer: interfaces.Container;\r\n\r\n\tproperties: { [key: string]: () => unknown };\r\n}\r\n\r\nfunction getClassAdministration(target: any) {\r\n\tlet administration: DiClassAdministration | undefined = target[AdministrationKey];\r\n\r\n\tif (!administration) {\r\n\t\tadministration = {\r\n\t\t\taccepts: false,\r\n\t\t};\r\n\r\n\t\tObject.defineProperty(target, AdministrationKey, {\r\n\t\t\tenumerable: false,\r\n\t\t\twritable: false,\r\n\t\t\tvalue: administration,\r\n\t\t});\r\n\t}\r\n\r\n\treturn administration;\r\n}\r\n\r\nfunction getInstanceAdministration(target: any): DiInstanceAdministration {\r\n\tlet administration: DiInstanceAdministration | undefined = target[AdministrationKey];\r\n\r\n\tif (!administration) {\r\n\t\tconst container = target.context as InversifyReactContextValue;\r\n\t\tif (!container) {\r\n\t\t\tthrow new Error('Cannot use resolve services without any providers in component tree.');\r\n\t\t}\r\n\r\n\t\tadministration = {\r\n\t\t\tcontainer,\r\n\t\t\tproperties: {},\r\n\t\t};\r\n\r\n\t\tObject.defineProperty(target, AdministrationKey, {\r\n\t\t\tenumerable: false,\r\n\t\t\twritable: false,\r\n\t\t\tvalue: administration,\r\n\t\t});\r\n\t}\r\n\r\n\treturn administration;\r\n}\r\n\r\nfunction ensureAcceptContext(target: ComponentClass) {\r\n\tconst administration = getClassAdministration(target);\r\n\r\n\tif (!administration.accepts) {\r\n\t\tconst { contextType } = target;\r\n\t\tconst componentName = target.displayName || target.name;\r\n\t\tif (contextType) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'inversify-react cannot configure React context.\\n'\r\n\t\t\t\t+ `Component \\`${componentName}\\` already has \\`${contextTypeKey}: ${contextType.displayName || '<anonymous context>'}\\` defined.\\n`\r\n\t\t\t\t+ '@see inversify-react/test/resolve.tsx#limitations for more info and workarounds\\n'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tObject.defineProperty(target, contextTypeKey, {\r\n\t\t\tenumerable: true,\r\n\t\t\tget() {\r\n\t\t\t\treturn InversifyReactContext;\r\n\t\t\t},\r\n\t\t\tset(value: unknown) {\r\n\t\t\t\tif (value !== InversifyReactContext) {\r\n\t\t\t\t\t// warn users if they also try to use `contextType` of this component\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t`Cannot change \\`${contextTypeKey}\\` of \\`${componentName}\\` component.\\n`\r\n\t\t\t\t\t\t+ 'Looks like you are using inversify-react decorators, '\r\n\t\t\t\t\t\t+ 'which have already patched this component and use own context to deliver IoC container.\\n'\r\n\t\t\t\t\t\t+ '@see inversify-react/test/resolve.tsx#limitations for more info and workarounds\\n'\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tadministration.accepts = true;\r\n\t}\r\n}\r\n\r\ntype PropertyOptions = Readonly<{\r\n\tisOptional?: boolean;\r\n\tdefaultValue?: unknown;\r\n}>;\r\n\r\nfunction createProperty(target: Component, name: string, type: interfaces.ServiceIdentifier<unknown>, options: PropertyOptions) {\r\n\tObject.defineProperty(target, name, {\r\n\t\tenumerable: true,\r\n\t\tget() {\r\n\t\t\tconst administration = getInstanceAdministration(this);\r\n\t\t\tlet getter = administration.properties[name];\r\n\r\n\t\t\tif (!getter) {\r\n\t\t\t\tconst { container } = administration;\r\n\r\n\t\t\t\tlet value: unknown;\r\n\t\t\t\tif (options.isOptional)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (container.isBound(type)) {\r\n\t\t\t\t\t\tvalue = container.get(type);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvalue = options.defaultValue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tvalue = container.get(type);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgetter = administration.properties[name] = () => value;\r\n\t\t\t}\r\n\r\n\t\t\treturn getter();\r\n\t\t}\r\n\t});\r\n\r\n\tconst descriptor = Object.getOwnPropertyDescriptor(target, name);\r\n\tif (!descriptor)\r\n\t\tthrow new Error('Failed to define property');\r\n\r\n\treturn descriptor;\r\n}\r\n\r\nexport {\r\n\tInversifyReactContext,\r\n\tAdministrationKey,\r\n\tDiClassAdministration, DiInstanceAdministration,\r\n\tensureAcceptContext,\r\n\tcreateProperty, PropertyOptions,\r\n\tgetClassAdministration, getInstanceAdministration,\r\n};\r\n","import * as React from 'react';\r\nimport { useContext, useState } from 'react';\r\nimport { interfaces } from 'inversify';\r\nimport { InversifyReactContext } from './internal';\r\n\r\ntype ProviderProps = Readonly<{\r\n    // Inversify container (or container factory) to be used for that React subtree (children of Provider)\r\n    container: interfaces.Container | (() => interfaces.Container);\r\n\r\n    // Hierarchical DI configuration:\r\n    // standalone Provider will keep container isolated,\r\n    // otherwise (default behavior) it will try to find parent container in React tree\r\n    // and establish hierarchy of containers\r\n    // @see https://github.com/inversify/InversifyJS/blob/master/wiki/hierarchical_di.md\r\n    standalone?: boolean;\r\n\r\n    // TODO:ideas: more callbacks?\r\n    //  ---\r\n    //  `onReady?: (container: interfaces.Container) => void`\r\n    //  before first render, but when hierarchy is already setup (because parent container might be important ofc),\r\n    //  e.g. to preinit something, before it gets used by some components:\r\n    //  ```\r\n    //  onReady={container => {\r\n    //    // e.g. when container comes from business-logic-heavy external module, independent from UI (React),\r\n    //    // and requires a little bit of additional UI-based configuration\r\n    //    container.get(Foo).initBasedOnUI(...)\r\n    //  }}\r\n    //  ```\r\n    //  ---\r\n    //  `onParent?: (self: interfaces.Container, parent: interfaces.Container) => interfaces.Container`\r\n    //  middleware-like behavior where we could intercept parent container and interfere with hierarchy or something\r\n    //\r\n}>;\r\n\r\n// very basic typeguard, but should be enough for local usage\r\nfunction isContainer(x: ProviderProps['container']): x is interfaces.Container {\r\n\treturn 'resolve' in x;\r\n}\r\n\r\nconst Provider: React.FC<ProviderProps> = ({\r\n    children,\r\n    container: containerProp,\r\n    standalone: standaloneProp = false\r\n}) => {\r\n    // #DX: guard against `container` prop change and warn with explicit error\r\n    const [container] = useState(containerProp);\r\n    // ...but only if it's an actual Container and not a factory function (factory can be a new function on each render)\r\n\tif (isContainer(containerProp) && containerProp !== container) {\r\n\t\tthrow new Error(\r\n\t\t\t'Changing `container` prop (swapping container in runtime) is not supported.\\n' +\r\n\t\t\t'If you\\'re rendering Provider in some list, try adding `key={container.id}` to the Provider.\\n' +\r\n\t\t\t'More info on React lists:\\n' +\r\n\t\t\t'https://reactjs.org/docs/lists-and-keys.html#keys\\n' +\r\n\t\t\t'https://reactjs.org/docs/reconciliation.html#recursing-on-children'\r\n\t\t);\r\n\t}\r\n\r\n    // #DX: guard against `standalone` prop change and warn with explicit error\r\n    const [standalone] = useState(standaloneProp);\r\n    if (standaloneProp !== standalone) {\r\n        throw new Error(\r\n            'Changing `standalone` prop is not supported.' // ...does it make any sense to change it?\r\n        );\r\n    }\r\n\r\n    // we bind our container to parent container BEFORE first render,\r\n    // so that children would be able to resolve stuff from parent containers\r\n    const parentContainer = useContext(InversifyReactContext);\r\n    useState(function prepareContainer() {\r\n        if (!standalone && parentContainer) {\r\n            if (parentContainer === container) {\r\n                throw new Error(\r\n                    'Provider has found a parent container (on surrounding React Context), ' +\r\n                    'yet somehow it\\'s the same as container specified in props. It doesn\\'t make sense.\\n' +\r\n                    'Perhaps you meant to configure Provider as \\`standalone={true}\\`?'\r\n                );\r\n            }\r\n            if (container.parent) {\r\n                throw new Error(\r\n                    'Ambiguous containers hierarchy.\\n' +\r\n                    'Provider has found a parent for specified `container`, but it already has a parent.\\n' +\r\n                    'Learn more at https://github.com/Kukkimonsuta/inversify-react/blob/v0.5.0/src/provider.tsx'\r\n                    // It is likely one of two:\r\n                    //\r\n                    // 1) If existing `container.parent` is not an accident (e.g. you already control hierarchy),\r\n                    //    then you should use `standalone` configuration\r\n                    //    <Provider container={myContainer} standalone={true}>\r\n                    //    so that inversify-react Provider won't try to set parent container (found on React Context)\r\n                    //\r\n                    // 2) Perhaps existing `container.parent` is an accident (???)\r\n                    //    and you actually would rather want to use container from surrounding React Context as parent,\r\n                    //    then you unset `container.parent` first.\r\n                    //\r\n                    // More info on hierarchical DI:\r\n                    // https://github.com/inversify/InversifyJS/blob/master/wiki/hierarchical_di.md'\r\n                );\r\n            }\r\n\r\n            container.parent = parentContainer;\r\n        }\r\n    });\r\n\r\n    return (\r\n        <InversifyReactContext.Provider value={container}>\r\n            {children}\r\n        </InversifyReactContext.Provider>\r\n    );\r\n};\r\n\r\nexport { ProviderProps, Provider };\r\nexport default Provider;\r\n","import { interfaces } from 'inversify';\r\nimport { ensureAcceptContext, createProperty, PropertyOptions } from './internal';\r\n\r\ninterface ResolveDecorator {\r\n\t(serviceIdentifier: interfaces.ServiceIdentifier<unknown>): (target: any, name: string, descriptor?: any) => any;\r\n\t(target: any, name: string, descriptor?: any): any\r\n\r\n\toptional: ResolveOptionalDecorator;\r\n}\r\n\r\ninterface ResolveOptionalDecorator {\r\n\t<T>(serviceIdentifier: interfaces.ServiceIdentifier<T>, defaultValue?: T): (target: any, name: string, descriptor?: any) => any;\r\n\t(target: any, name: string, descriptor?: any): any;\r\n}\r\n\r\nfunction applyResolveDecorator(target: any, name: string, type: interfaces.ServiceIdentifier<unknown>, options: PropertyOptions) {\r\n\tensureAcceptContext(target.constructor);\r\n\r\n\treturn createProperty(target, name, type, options);\r\n}\r\n\r\nfunction getDesignType(target: any, name: string) {\r\n\tif (!name) {\r\n\t\tthrow new Error('Decorator `resolve` failed to resolve property name');\r\n\t}\r\n\r\n\tif (!Reflect || !Reflect.getMetadata) {\r\n\t\tthrow new Error('Decorator `resolve` without specifying service identifier requires `reflect-metadata`');\r\n\t}\r\n\r\n\tconst type = Reflect.getMetadata('design:type', target, name);\r\n\tif (!type) {\r\n\t\tthrow new Error('Failed to discover property type, is `emitDecoratorMetadata` enabled?');\r\n\t}\r\n\r\n\treturn type;\r\n}\r\n\r\nconst resolve = <ResolveDecorator>function resolve(target: any, name: string, descriptor?: any) {\r\n\tif (typeof name !== 'undefined') {\r\n\t\tconst type = getDesignType(target, name);\r\n\r\n\t\t// decorator\r\n\t\treturn applyResolveDecorator(target, name, type, {});\r\n\t} else {\r\n\t\tconst serviceIdentifier = target as interfaces.ServiceIdentifier<unknown>;\r\n\t\tif (!serviceIdentifier) {\r\n\t\t\tthrow new Error('Invalid property type.');\r\n\t\t}\r\n\r\n\t\t// factory\r\n\t\treturn function(target: any, name: string, descriptor?: any) {\r\n\t\t\treturn applyResolveDecorator(target, name, serviceIdentifier, {});\r\n\t\t};\r\n\t}\r\n};\r\n\r\nresolve.optional = <ResolveOptionalDecorator>function resolveOptional<T>(...args: unknown[]) {\r\n\tif (typeof args[1] === 'string' && args.length === 3) {\r\n\t\tconst [target, name, descriptor] = args;\r\n\t\tconst type = getDesignType(target, name);\r\n\r\n\t\t// decorator\r\n\t\treturn applyResolveDecorator(target, name, type, { isOptional: true });\r\n\t} else {\r\n\t\tconst serviceIdentifier = args[0] as interfaces.ServiceIdentifier<T>;\r\n\t\tconst defaultValue = args[1] as T | undefined;\r\n\r\n\t\t// factory\r\n\t\treturn function(target: any, name: string, descriptor?: any) {\r\n\t\t\treturn applyResolveDecorator(target, name, serviceIdentifier, { isOptional: true, defaultValue });\r\n\t\t};\r\n\t}\r\n}\r\n\r\nexport { resolve };\r\nexport default resolve;\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__888__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export { resolve } from './resolve';\r\nexport { Provider, ProviderProps } from './provider';\r\nexport {\r\n    useAllInjections,\r\n    useContainer,\r\n    useInjection,\r\n    useOptionalInjection,\r\n} from './hooks';\r\n"],"sourceRoot":""}